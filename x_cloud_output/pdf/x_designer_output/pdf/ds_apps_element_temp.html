<div class="post-header">
    <h1 class="post-title-main" id="ds_apps_element_temp.html">Create an Element Template</h1>
</div>

<div class="post-content">

    
    <div class="summary">Templates are the core component of an element. The template is the actual HTML content that will be rendered on a users page.</div>
    
    <p>All templates make use of <a href="http://mustache.github.io/mustache.5.html">Mustache</a> for the templating language. Your template can include static HTML and the following dynamic content:</p>
<ul>
  <li><strong>Content fields</strong>: You can insert text, button, and image components that the user can edit.</li>
  <li><strong>Settings</strong>: You can access values for <a href="ds_apps_element_settings.html">settings</a>  that the user has set on the element (you create settings in the manifest file).</li>
  <li><strong>Data</strong>: Your template can include the values for the element, user, and site IDs, as well as the path to the element assets.</li>
</ul>

<h2 id="editor-vs-published-templates">Editor vs. Published Templates</h2>

<p>Templates (<code class="highlighter-rouge">.tpl</code> files) are located in an <a href="ds_apps_element_folders.html">html folder</a> in the root of your element.  You need to create at least one template named <code class="highlighter-rouge">element.tpl</code>, which will be used for both the editor and the published site.  You can also provide an <code class="highlighter-rouge">editor_element.tpl</code> file to be used only within the editor.  This allows you to specify a different UI (or an augmented UI) within the editor. This may be necessary when your element requires major interactivity with the user on a published site, as the element placeholder in the editor can handle only basic interaction, such as direct editing.</p>

<h2 id="add-content-fields">Add Content Fields</h2>

<p>​Content fields are small sections of your element that are directly editable by the user.  They make use of existing Weebly components, providing a consistent UI between your element and the Weebly ecosystem. ​Weebly supports four types of content fields:</p>
<ul>
  <li>text</li>
  <li>image</li>
  <li>button</li>
  <li>content (which allows the user to drag elements into this element).</li>
</ul>

<p>This example shows the syntax for defining a field:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
    {unique_name:field_type default="Default Text Here"}
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<p>For example:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
    {name:text default="Put your name here"}
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<p>Every content field must have a unique name. If two content fields share a name, only the first one will act as an editable content field, with the other remaining as text within the element.
​</p>

<div class="Notice type_info" role="alert">
	<b>Note:</b> The DOM structure generated for the element differs between the editor and published sites.  You need to account for both DOM structures when styling your element.
</div>

<p>If you want to be able to hide/display different areas of content at a time, then use CSS to set visibility and any content set to visible will be displayed. You can also set a width on the content area, for example, <code class="highlighter-rouge"><span class="p">{</span><span class="err">myContentArea:content</span><span class="w"> </span><span class="err">width=</span><span class="nt">"50%"</span><span class="err">}</span></code>. If a user moves or copies a <code class="highlighter-rouge"><span class="p">{</span><span class="err">content</span><span class="p">}</span></code> field, all child elements will get moved/copied as well.</p>

<h2 id="access-settings">Access Settings</h2>

<p>Within your template(s), you can access element settings using Mustache tags.  Each setting is represented by the <code class="highlighter-rouge">name</code> attribute specified in the manifest.json.</p>

<p>When accessing settings, you can generate unique names for the content fields by using element settings as part of the name. For example, <code class="highlighter-rouge"><span class="p">{</span><span class="err">name_:text</span><span class="p">}</span></code> and <code class="highlighter-rouge"><span class="p">{</span><span class="err">name_:text</span><span class="p">}</span><span class="w"> </span></code>are unique.</p>

<p>For example, the Price Chart allows the user to set Plan names. Plans have manifest entry like this:</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="s2">"properties"</span><span class="err">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
</span><span class="err">{</span><span class="w">
    </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"plans"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Plans"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"int"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"default"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
    </span><span class="nt">"step"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nt">"min"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nt">"tooltip"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Select the number of plans to display."</span><span class="w">
</span><span class="p">},</span><span class="w">
</span><span class="err">.</span><span class="w"> </span><span class="err">.</span><span class="w"> </span><span class="err">.</span><span class="w">
</span><span class="err">}</span><span class="p">]</span></code></pre></figure>

<p>The template for the Price Chart uses this to create that text field:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
    {name_{{plans}}:text default="Plan Name"}
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<p>You need to be careful when using a setting value within a Content Field. <code>&#123;&#123;&#123;setting_name&#125;&#125;_field:text&#125;</code> is an invalid field!  This is because the template system can’t discern whether you’re trying to use an unescaped <a href="http://mustache.github.io/mustache.5.html#TAG-TYPES">Mustache tag</a>, or using a standard tag within one of our content fields.  To mitigate this, always start content field names with a static sting: <code>&#123;some_prefix_&#123;&#123;setting_name&#125;&#125;:text&#125;</code>.</p>

<p>​For any integer settings, we generate a iterable value for you, allowing you to perform loops within your templates. For any integer setting with a value less than 100, we generate an iterable setting item with the same name as your setting, appended with _each.  Within your loop, you can access the current index with the setting name appended with _index.</p>

<p>For example, using the above manifest entry for plans, you can iterate over the instances like this:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
    {{#plans_each}}
    {name_{{plans_index}}:text default="Plan Name"}
    {{/plans_each}}
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<div class="Notice type_info" role="alert">
	<b>Note:</b> There is potential for name collisions here! If you have a setting named <code class="highlighter-rouge">plans</code>, and also a setting named <code class="highlighter-rouge">plans_each</code>, we will not generate the iterable value for you!
</div>

<div class="Notice type_info" role="alert">
	<b>Note:</b> We will not generate loops for values that are greater than 100, for performance reasons.  If you have a setting that you intend to use as a loop, be sure to set appropriate minimums and maximums!
</div>

<h2 id="access-additional-data">Access Additional Data</h2>

<p>Within your template, you also have access to additional data.  Every piece of data is accessed in a similar way to settings, using mustache tags.  You can access the following:</p>

<ul>
  <li><code class="highlighter-rouge">assets_path</code>: This is the HTTP accessible root path to your elements’ <code class="highlighter-rouge">assets</code> folder, in protocol-agnostic form. The path contains the trailing slash.</li>
</ul>

<figure class="highlight"><pre><code class="language-html" data-lang="html">   <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
     <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"your_image.png"</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/div&gt;</span></code></pre></figure>

<div class="Notice type_info" role="alert">
	<b>Note:</b> If you provide a setting named <code class="highlighter-rouge">assets_path</code> in your manifest, it will be overridden with this value.
</div>

<ul>
  <li><code class="highlighter-rouge">element_id</code>, <code class="highlighter-rouge">user_id</code>, <code class="highlighter-rouge">site_id</code>: These are the respective ID’s for the current user, site, and element instance.  You can access these in your templates using standard Mustache syntax:</li>
</ul>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"example"</span><span class="nt">&gt;</span>
    {{user_id}} - {{site_id}} - {{element_id}}
<span class="nt">&lt;/div&gt;</span></code></pre></figure>

<div class="Notice type_info" role="alert">
	<b>Note:</b> We can not guarantee that <code class="highlighter-rouge">element_id</code> and <code class="highlighter-rouge">site_id</code> will be universally unique.  We recommend that you use a composite key for any storage you may be doing on your servers or services!
</div>

<h2 id="use-iframes">Use IFrames</h2>

<p>If your element contains an iframe, we will automatically add an additional invisible overlay <code class="highlighter-rouge">div</code> for your element. This <code class="highlighter-rouge">div</code> ensures that Weebly users will have a clickable target for accessing settings. Once the settings panel is opened, the overlay is removed so that users can interact with your iframe.</p>

<div class="Notice type_info" role="alert">
	<b>Note:</b> If you dynamically add an iframe after page load, our system may not properly add an overlay <code class="highlighter-rouge">div</code>.  This will cause users to be unable to access your element settings!  Please try to avoid dynamically creating iframes during the lifecycle of your element.
</div>


</div>
